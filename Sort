#include <iostream>
#include <vector>
#include <stdlib.h>
#include <time.h>
using namespace std;

//1. 直接插入排序
void InsertSort(vector<int>& v, int n)
{
	for (int i = 0; i < n - 1; ++i)
	{
		//单个元素的排序
		int end = i;
		int tmp = v[end + 1];
		while (end >= 0 && v[end] > tmp)
		{
			v[end + 1] = v[end];
			--end;
		}
		v[end + 1] = tmp;
	}
}

//2. 希尔排序: 对插排进行优化, 先预排序
void ShellSort(vector<int>& v, int n)
{
	int gap = n;
	while (gap > 1)
	{
		//gap > 1 : 预排序
		//gap == 1 : 排序过程
		//+1 保证最后一次是一个间隔为1的插入排序
		gap = gap / 3 + 1;
		for (int i = 0; i < n - gap; ++i)
		{
			int end = i;
			int tmp = v[end + gap];
			while (end >= 0 && v[end] > tmp)
			{
				v[end + gap] = v[end];
				end -= gap;
			}
			v[end + gap] = tmp;
		}
	}
}

//3. 直接选择排序
void SelectSort1(vector<int>& v, int n)
{
	//每次选一个最小的
	for (int i = 0; i < n; ++i)
	{
		//保存最小元素的下标
		int Min = i;
		for (int j = i + 1; j < n; ++j)
		{
			if (v[j] < v[Min])
				Min = j;
		}
		//将元素放在指定位置
		swap(v[i], v[Min]);
	}
}

void SelectSort2(vector<int>& v, int n)
{
	//每次选择一个最大一个最小, 放到相应位置
	int begin = 0;
	int end = n - 1;
	while (begin < end)
	{
		int Max, Min;
		Max = Min = begin;
		//小的选第一个, 大的选最后一个, 就稳定了, 相同的元素位置不会发生变化
		for (int i = begin; i <= end; ++i)
		{
			if (v[i] < v[Min])
				Min = i;
			if (v[i] >= v[Max])
				Max = i;
		}
		swap(v[begin], v[Min]);
		//判断最大元素的位置是否发生了变化, 如果变化了, 就是被交换了, 让下标指向被交换的地方
		if (Max == begin)
			Max = Min;
		swap(v[end], v[Max]);
		++begin;
		--end;
	}
}

void SelectSort3(vector<int>& v, int n)
{
	for (int i = 0; i < n; ++i)
	{
		for (int j = i + 1; j < n; ++j)
		{
			if (v[i] > v[j])
				swap(v[i], v[j]);
		}
	}
}

//4. 堆排序
//建堆: O(n)
void ShiftDown(vector<int>& v, int n, int root)
{
	int parent = root;
	int child = 2 * root + 1;
	//判断是否有孩子
	while (child < n)
	{
		//是否有右孩子, 如果有, 选最大
		if (child + 1 < n && v[child] < v[child + 1])
		{
			++child;
		}
		//孩子是否大于父亲
		if (v[child] > v[parent])
		{
			//交换孩子和父亲
			swap(v[child], v[parent]);
			//更新下一个调整的位置
			parent = child;
			child = 2 * child + 1;
		}
		else
			break;
	}
}
//排序: O(n * logn)
void HeapSort(vector<int>& v, int n)
{
	//建堆, 最后一棵子树开始 : (n - 2) / 2
	for (int i = (n - 2) / 2; i >= 0; --i)
	{
		ShiftDown(v, n, i);
	}
	//排序: 1. swap  2. ShiftDown
	int end = n - 1;
	while (end)
	{
		swap(v[0], v[end]);
		ShiftDown(v, end, 0);
		--end;
	}
}

//5. 冒泡排序
void BubbleSort(vector<int>& v, int n)
{
	for (int i = 0; i < n; ++i)
	{
		bool flag = false;
		for (int j = n - 1; j > i; --j)
		{
			if (v[j] < v[j - 1])
			{
				swap(v[j], v[j - 1]);
				flag = true;
			}
		}
		if (!flag)
			break;
	}
}

void Print(vector<int> v)
{
	for (auto e : v)
	{
		cout << e << ' ';
	}
	cout << endl;
}

void TestSort()
{
	srand(time(NULL));
	int num;
	cin >> num;
	vector<int> v(num);
	for (int i = 0; i < num; ++i)
	{
		v[i] = rand();
	}
	vector<int> v1 = v;
	vector<int> v2 = v;
	vector<int> v3 = v;
	vector<int> v4 = v;
	vector<int> v5 = v;
	vector<int> v21 = v;
	vector<int> v23 = v;
	size_t begin1, end1, begin2, end2, begin21, end21, begin23, end23;
	size_t begin3, end3, begin4, end4, begin5, end5;

	begin3 = clock();
	InsertSort(v3, v3.size());
	end3 = clock();
	cout << "InsertSort: " << end3 - begin3 << endl;

	begin4 = clock();
	ShellSort(v4, v4.size());
	end4 = clock();
	cout << "ShellSort: " << end4 - begin4 << endl;	

	begin2 = clock();
	SelectSort2(v2, v2.size());
	end2 = clock();
	cout << "SelectSort2: " << end2 - begin2 << endl;

	begin21 = clock();
	SelectSort1(v21, v21.size());
	end21 = clock();
	cout << "SelectSort1: " << end21 - begin21 << endl;

	begin23 = clock();
	SelectSort3(v23, v23.size());
	end23 = clock();
	cout << "SelectSort3: " << end23 - begin23 << endl;

	begin1 = clock();
	HeapSort(v1, v1.size());
	end1 = clock();
	cout << "HeapSort: " << end1 - begin1 << endl;

	begin5 = clock();
	BubbleSort(v5, v5.size());
	end5 = clock();
	cout << "BubbleSort: " << end5 - begin5 << endl;
}


int main()
{
	//vector<int> v{ 3, 2, 1, 8, 5, 4, 7, 9, 6, 0 };
	//Print(v);
	//SelectSort3(v, v.size());
	//Print(v);

	TestSort();
    system("pause");
	return 0;	
}
